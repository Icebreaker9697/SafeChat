package hello;

import java.util.ArrayList;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import hello.User;
import hello.UserRepository;

@Controller //This means that this class is a Controller
@RequestMapping(path="/demo") // This means URL's start with /demo (after Application path)
public class MainController{
	
	private static final String REQUESTED = "requested";
	private static final String NEEDSTORESPOND = "needsToRespond";
	private static final String REJECTED = "rejectedBy";
	private static final String FRIENDS = "friends";
	private static final String NOTFRIENDS = "notFriends";
	
	@Autowired //This means to get the bean called userRepository
				// Which is auto-generated by Spring. We will use it to handle the data
	private UserRepository userRepository;
	
	@Autowired //This means to get the bean called userRepository
	// Which is auto-generated by Spring. We will use it to handle the data
	private UserRelationshipsRepository userRelationshipsRepository;

	
	@GetMapping(path="/enc")
	public @ResponseBody String enc(@RequestParam String payloadCipher, @RequestParam String encryptedKey) {
		String symmetricKey = decryptKey(encryptedKey);
		String[] msg = decryptMsg(payloadCipher, symmetricKey).split("\\?");
		String action = msg[0];
		String username = "";
		String fromUser = "";
		String toUser = "";
		switch(action) {
			case "login":
				username = msg[1];
				String password = msg[2];
				return login(username, password, userRepository, symmetricKey);
			case "add":
				username = msg[1];
				String passHash = msg[2];
				String userPublicKey = msg[3];
				String userPrivateKey = msg[4];
				return addNewUser(username, passHash, userPublicKey, userPrivateKey, userRepository, symmetricKey);
			case "requestfriend":
				fromUser = msg[1];
				toUser = msg[2];
				return sendFriendRequest(fromUser, toUser, userRelationshipsRepository, userRepository, symmetricKey);
			case "getrequests":
				username = msg[1];
				return getFriendRequests(username, userRelationshipsRepository, symmetricKey);
			case "rejectrequest":
				fromUser = msg[1];
				toUser = msg[2];
				return rejectFriendRequest(fromUser, toUser, userRelationshipsRepository, userRepository, symmetricKey);
			case "getfriends":
				username = msg[1];
				return getFriendships(username, userRelationshipsRepository, symmetricKey);
				
			default: return encryptMsg("Server did not understand message.", symmetricKey);
		}
	}
	
	/*Used for user registration*/
	public static String addNewUser(String username, String passHash, String userPublicKey, String encryptedUserPrivateKey, UserRepository userRepository, String symmetricKey){

		User u = userRepository.findByUsername(username);

		String msg = "";
		
		if(u != null) {
			msg = "User with that username already exists!";
			String enc = encryptMsg(msg, symmetricKey);
			return enc;
		}

		User n = new User();
		n.setUsername(username);
		n.setPassHash(passHash);
		n.setUserPublicKey(userPublicKey);
		n.setEncryptedUserPrivateKey(encryptedUserPrivateKey);

		userRepository.save(n);
		msg = "Success";
		String enc = encryptMsg(msg, symmetricKey);
		return enc;
	}
	
	/*used for user login*/
	public static String login(String username, String enteredPassword, UserRepository userRepository, String symmetricKey){
		User u = userRepository.findByUsername(username);
		String msg = "";
		if(u == null) {
			msg = "nologin";
			String enc = encryptMsg(msg, symmetricKey);
			return enc;
		}
		
		String originalPassword = u.getPassHash();
		
		if(!Hasher.validatePassword(enteredPassword, originalPassword)) {
			msg = "wrong";
		}else {
			String resp = "";
			resp = resp + u.getUsername() + "?" + u.getEncryptedUserPrivateKey() + "?" + u.getUserPublicKey();
			msg = resp;
		}
		
		String enc = encryptMsg(msg, symmetricKey);
		return enc;
	}
	
	/*used for users to reject a friend request*/
	public static String rejectFriendRequest(String from, String to, UserRelationshipsRepository userRelationshipsRepository, UserRepository userRepository, String symmetricKey) {
		//check if the targetUser even exists
				User k = userRepository.findByUsername(to);
				String msg = "";
				if(k == null) {
					msg = "usernotexist";
					String enc = encryptMsg(msg, symmetricKey);
					return enc;
				}
				
				//find a relationship between fromUser and toUser, if it exists
				UserRelationships existingRln = findRelationship(from, to, userRelationshipsRepository);
				
				//if there was an existing relationship
				if(existingRln != null) {
					//set relationship status as not friends
					existingRln.setRelationshipType(NOTFRIENDS);
					
					//set the relationship type of the other persons to rejectedby
					UserRelationships targetRln = findRelationship(to, from, userRelationshipsRepository);
					targetRln.setRelationshipType(REJECTED);
					
					userRelationshipsRepository.save(existingRln);
					userRelationshipsRepository.save(targetRln);
					msg = "rejectedfriends";
					String enc = encryptMsg(msg, symmetricKey);
					return enc;
				}
				
				//There was not any existing relationship
				msg = "notFound";
				String enc = encryptMsg(msg, symmetricKey);
				return enc;
	}
	
	/*used for users to get their friends list*/
	public static String getFriendships(String username, UserRelationshipsRepository userRelationshipsRepository, String symmetricKey) {
		//get list of all of source's relationships
		List<UserRelationships> u = userRelationshipsRepository.findByFromUsername(username);
		
		List<String> friendRequests = new ArrayList<>();
		
		//check to see if the user had any relationships at all
		if(u != null && u.size() > 0) {
			//iterate through all of their relationships and add the ones that are of type "needsToRespond"
			for(int i = 0; i < u.size(); i++) {
				UserRelationships tmpRelationship = u.get(i);
				if(tmpRelationship.getRelationshipType().equals(FRIENDS)) {
					friendRequests.add(tmpRelationship.getToUsername());
				}
			}
		}
		
		String res = "";
		if(friendRequests.size() == 0) {
			res = "noFriends";
		} else {
			for(int i = 0; i < friendRequests.size(); i++) {
				res = res + friendRequests.get(i) + "?";
			}
			res = res.substring(0, res.length() - 1);
		}
		
		String enc = encryptMsg(res, symmetricKey);
		return enc;
	}
	
	/*used for users to get the list of friend requests to them*/
	public static String getFriendRequests(String username, UserRelationshipsRepository userRelationshipsRepository, String symmetricKey) {
		//get list of all of source's relationships
		List<UserRelationships> u = userRelationshipsRepository.findByFromUsername(username);
		
		List<String> friendRequests = new ArrayList<>();
		
		//check to see if the user had any relationships at all
		if(u != null && u.size() > 0) {
			//iterate through all of their relationships and add the ones that are of type "needsToRespond"
			for(int i = 0; i < u.size(); i++) {
				UserRelationships tmpRelationship = u.get(i);
				if(tmpRelationship.getRelationshipType().equals(NEEDSTORESPOND)) {
					friendRequests.add(tmpRelationship.getToUsername());
				}
			}
		}
		
		String msg = "";
		if(friendRequests.size() == 0) {
			msg = "noRequests";
			String enc = encryptMsg(msg, symmetricKey);
			return enc;
		} else {
			for(int i = 0; i < friendRequests.size(); i++) {
				msg = msg + friendRequests.get(i) + "?";
			}
			msg = msg.substring(0, msg.length() - 1);
		}
		
		String enc = encryptMsg(msg, symmetricKey);
		return enc;
	}
	
	private static String decryptKey(String encryptedKey) {
		String decryptedKey = RSACipher.decryptWithPrivate(ServerInfo.PRIVATEKEY, encryptedKey);
		return decryptedKey;
	}
	
	private static String decryptMsg(String payloadCipher, String symmetricKey) {
		return SymmetricCipher.decrypt(symmetricKey, payloadCipher, true);
	}
	
	private static String encryptMsg(String msg, String symmetricKey) {
		return SymmetricCipher.encrypt(symmetricKey, msg, true);
	}
	
	/*used for users to send a friend request*/
	private static String sendFriendRequest(String fromUser, String toUser, UserRelationshipsRepository userRelationshipsRepository, UserRepository userRepository, String symmetricKey) {
		//check if the targetUser even exists
		User k = userRepository.findByUsername(toUser);
		String msg = "";
		
		if(k == null) {
			msg = "usernotexist";
			String enc = encryptMsg(msg, symmetricKey);
			return enc;
		}
		
		//find a relationship between fromUser and toUser, if it exists
		UserRelationships existingRln = findRelationship(fromUser, toUser, userRelationshipsRepository);
		
		//if there was an existing relationship
		if(existingRln != null) {
			//are they already friends?
			if(existingRln.getRelationshipType().equals(FRIENDS)) {
				msg = "alreadyfriends";
				String enc = encryptMsg(msg, symmetricKey);
				return enc;
			} 
			
			//have they already sent the target a request?
			if(existingRln.getRelationshipType().equals(REQUESTED) || existingRln.getRelationshipType().equals(REJECTED)) {
				msg = "alreadyrequested";
				String enc = encryptMsg(msg, symmetricKey);
				return enc;
			}
			
			//else this user needsToRespond to a pending request from the target, or this user has previously rejected a request from the target
			existingRln.setRelationshipType(FRIENDS);
			
			//set the relationship type of the other persons to friends as well
			UserRelationships targetRln = findRelationship(toUser, fromUser, userRelationshipsRepository);
			targetRln.setRelationshipType(FRIENDS);
			
			userRelationshipsRepository.save(existingRln);
			userRelationshipsRepository.save(targetRln);
			msg = "becamefriends";
			String enc = encryptMsg(msg, symmetricKey);
			return enc;
		}
		
		//There was not any existing relationship
		UserRelationships u = new UserRelationships();
		u.setFromUsername(fromUser);
		u.setToUsername(toUser);
		u.setRelationshipType(REQUESTED);
		
		UserRelationships u2 = new UserRelationships();
		u2.setFromUsername(toUser);
		u2.setToUsername(fromUser);
		u2.setRelationshipType(NEEDSTORESPOND);
		userRelationshipsRepository.save(u);
		userRelationshipsRepository.save(u2);
		msg = "sentrequest";
		String enc = encryptMsg(msg, symmetricKey);
		return enc;
	}
	
	private static UserRelationships findRelationship(String source, String target, UserRelationshipsRepository userRelationshipsRepository) {
		//get list of all of source's relationships
		List<UserRelationships> u = userRelationshipsRepository.findByFromUsername(source);
		
		UserRelationships res = null;
		
		//check to see if the user had any relationships at all
		if(u != null && u.size() > 0) {
			//iterate through all of their relationships to see if there exists one with target
			for(int i = 0; i < u.size(); i++) {
				UserRelationships tmpRelationship = u.get(i);
				if(target.equals(tmpRelationship.getToUsername())) {
					res = tmpRelationship;
					break;
				}
			}
		}
		
		return res;
	}
}